# Задание debug set

В этом задании требуется написать класс, реализующий бинарное дерево поиска
(можно несбалансированное) и проверяющий корректность использования своих
методов.

## Требования к дереву поиска

Список функций, которые необходимо реализовать, указаны в файле `set.h`.
Семантика функций должна совпадать с поведением `std::set` из стандартной
библиотеки.

В `set.h` указана требуемая вычислительная сложность для каждой функции, кроме
`set::begin`, `set::end`, `set::iterator::operator++` и
`set::iterator::operator--`. Для них требуется, чтобы отдельно каждая из
функций работала не больше чем за `O(h)`, а также суммарно код
`for (auto i = s.begin(); i != s.end(); ++i);` работал за `O(n)`.

Пустой `set` никогда не должен аллоцировать динамическую память.

Вставка не должна инвалидировать никакие итераторы, удаление инвалидирует лишь
итераторы на удаляемые элементы, а `end()` остаётся всегда валидным.

Hint: итераторы удобно реализовать, используя идею с фейковой вершиной.

## Требования к дебажным проверкам

Класс должен детектить некорректные использования своих операций и завершать
исполнение программы при обнаружении некорректного использования. Примеры
некорректных использований:

1. Разыменование/инкремент/декремент/`erase()` невалидного итератора.
2. Разыменование итератора `end()`.
3. Инкремент `end()`.
4. Декремент `begin()`.
5. `erase()` итератора `end()`.

Общее правило: те операции, которые приводили бы к неопределённому поведению
в обычном `set`, здесь должны детектиться.

При обнаружении некорректного использования программу следует завершить
используя функцию `abort()` (её в частности вызывает `assert`).
Полноценная реализация возможно ещё бы печатала подробное диагностическое
сообщение о том, что именно за ошибка произошла, но в этом задании на этом
акцентировать внимание не нужно.

Для того чтобы выполнять проверки и поддерживать согласованность структуры
данных разрешается к времени работы любых операций добавить
`O(number_of_iterators)`, где `number_of_iterators` — число итераторов,
которые ссылаются на элементы `set`'а.

Рекомендуется сохранить гарантии безопасности исключений для всех операций
такими же, как они были у обычного `set`'а, но разрешается ослабить гарантии
у операций `begin()`, `end()`, `swap()` у `set`'а, а также у операций
копирования и присваивания у итераторов с `nothrow` на `strong`.
